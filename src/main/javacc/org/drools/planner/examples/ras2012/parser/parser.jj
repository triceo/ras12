options {  GENERATE_ANNOTATIONS=true;  GENERATE_CHAINED_EXCEPTION=true;  GENERATE_GENERICS=true;
  GENERATE_STRING_BUILDER=true;  STATIC=false;
  JDK_VERSION="1.7";
}
PARSER_BEGIN (DataSetParser)
package org.drools.planner.examples.ras2012.parser;import java.util.List;import java.util.ArrayList;import org.slf4j.LoggerFactory;import org.slf4j.Logger;public class DataSetParser {  public static final class ParsedTrain {    private final Token header;    private final Token timeEntry;    private final Token nodeOrigin;    private final Token nodeDestination;    private final Token direction;    private final Token speedMultiplier;    private final Token length;    private final Token TOB;    private final Token hazmat;    private final Token saStatus;    private final List<List<Token>> schedule = new ArrayList<List<Token>>();    private final List<Token> wantTime = new ArrayList<Token>();    public ParsedTrain(Token header, Token timeEntry, Token nodeOrigin,      Token nodeDestination, Token direction, Token speedMultiplier,      Token length, Token TOB, Token hazmat, Token saStatus,      List<List<Token > > schedule, List<Token > wantTime) {      this.header = header;      this.timeEntry = timeEntry;      this.nodeOrigin = nodeOrigin;      this.nodeDestination = nodeDestination;      this.direction = direction;      this.speedMultiplier = speedMultiplier;      this.length = length;      this.TOB = TOB;      this.hazmat = hazmat;      this.saStatus = saStatus;      this.schedule.addAll(schedule);      this.wantTime.addAll(wantTime);    }    public Token getHeader() {        return header;    }    public Token getTimeEntry() {        return timeEntry;    }    public Token getNodeOrigin() {        return nodeOrigin;    }    public Token getNodeDestination() {        return nodeDestination;    }    public Token getDirection() {        return direction;    }    public Token getSpeedMultiplier() {        return speedMultiplier;    }    public Token getLength() {        return length;    }    public Token getTOB() {        return TOB;    }    public Token getHazmat() {        return hazmat;    }    public Token getSaStatus() {        return saStatus;    }    public List<List<Token>> getSchedule() {        return schedule;    }    public List<Token> getWantTime() {        return wantTime;    }    @Override    public String toString() {        return "ParsedTrain [header=" + header + ", timeEntry=" + timeEntry + ", nodeOrigin=" + nodeOrigin + ", nodeDestination="                + nodeDestination + ", direction=" + direction + ", speedMultiplier=" + speedMultiplier + ", length=" + length                + ", TOB=" + TOB + ", hazmat=" + hazmat + ", saStatus=" + saStatus + ", schedule=" + schedule + ", wantTime="                + wantTime + "]";    }  }  private static final Logger logger = LoggerFactory.getLogger(DataSetParser.class);  private Token name;  private List<List<Token>> mows = new ArrayList<List<Token>>();  private List<List<Token>> arcs = new ArrayList<List<Token>>();  private List<Token> tracks = new ArrayList<Token>();  private List<Token> lengths = new ArrayList<Token>();  private List<ParsedTrain> trains = new ArrayList<ParsedTrain>();  private Token numTrains;  private Token speedWestbound;  private Token speedEastbound;  private Token speedSidings;  private Token speedCrossovers;  public Token getName() {    return name;  }  public List<List<Token>> getMows() {    return mows;  }  public List<List<Token>> getArcs() {    return arcs;  }  public List<Token> getTracks() {    return tracks;  }  public List<Token> getLengths() {    return lengths;  }  public List<ParsedTrain> getTrains() {    return trains;  }  public Token getNumTrains() {    return numTrains;  }  public Token getSpeedWestbound() {    return speedWestbound;  }  public Token getSpeedEastbound() {    return speedEastbound;  }  public Token getSpeedSidings() {    return speedSidings;  }  public Token getSpeedCrossovers() {    return speedCrossovers;  }  @Override  public String toString() {    return "DataSetParser [name=" + name + ", mows=" + mows + ", arcs=" + arcs + ", tracks=" + tracks + ", lengths="      + lengths + ", trains=" + trains + ", numTrains=" + numTrains + ", speedWestbound=" + speedWestbound      + ", speedEastbound=" + speedEastbound + ", speedSidings=" + speedSidings + ", speedCrossovers="      + speedCrossovers + "]";   }}PARSER_END (DataSetParser)// whitespaceTOKEN : {< TAB: "\t" >}TOKEN : {< SPACE: " " >}TOKEN : {< EOL: "\r" | "\n" | "\r\n" >}TOKEN : {< DOT: "." >}// numbersTOKEN : {< INTEGER : (["0" - "9"])+ >}TOKEN : {< NEGATE : "-" >}TOKEN : {< NEGATIVE_INTEGER : < NEGATE > (["0" - "9"])+ >}TOKEN : {< FLOAT : (<NEGATE>)? <INTEGER> | (<NEGATE>)? <INTEGER>  "." <INTEGER>  | (<NEGATE>)? <INTEGER> "." | (<NEGATE>)? "." <INTEGER> >} // variablesTOKEN : {< TRACK_NAME: "SW" | "S" | "C" >}TOKEN : {< TRAIN_TYPE: ["A"-"F"] >}TOKEN : {< TRAIN_NAME: < TRAIN_TYPE > < INTEGER > >}TOKEN : {< DIRECTION: "EASTBOUND" | "WESTBOUND" >}TOKEN : {< DEPOT: "EAST" | "WEST" >}TOKEN : {< YESNO: "YES" | "NO" >}TOKEN : {< TERRITORY_NAME: ["A"-"Z"] (["A"-"Z"," "])+ (< INTEGER >)? >}// pure stringsTOKEN : {< SPEED_UNIT: "mph" >}TOKEN : {< BETWEEN_NODES: "between nodes " >}TOKEN : {< MOW: "MOW:" >}TOKEN : {< AND: " and " >}void parse() : {  List<Token> oneArc;  Token oneTrack;  Token oneLength;  ParsedTrain oneTrain;}{  "TERRITORY:" < TAB > name=< TERRITORY_NAME >  (< TAB >)*  (< EOL >)+  "DEFAULT SPEED on MAIN TRACKS, WEST -> EAST:" < TAB > speedEastbound=< INTEGER > < TAB > < SPEED_UNIT >  (< EOL >)+  "DEFAULT SPEED on MAIN TRACKS, EAST -> WEST:" < TAB > speedWestbound=< INTEGER > < TAB > < SPEED_UNIT >  (< EOL >)+  "MAXIMUM SPEED on SIDINGS, both directions, all trains:" < TAB > speedSidings=< INTEGER > < TAB > < SPEED_UNIT >  (< EOL >)+  "MAXIMUM SPEED on CROSSOVERS and SWITCHES, both directions, all trains:" < TAB > speedCrossovers=< INTEGER > < TAB > < SPEED_UNIT >  (< EOL >)+  mows=parseMOW()  "ARC ID (WEST -> EAST, all bidirectional):" (< TAB > oneArc=parseArc()  {    logger.info("Adding one Arc with the following values: " + oneArc);    arcs.add(oneArc);  })+  (< EOL >)+  "TRACKTYPE (Main 0, 1, 2, Switch (SW), Siding (S), Crossover (C)):" (< TAB > (oneTrack=< TRACK_NAME > | oneTrack=< INTEGER >)  {    logger.info("Adding one track type: " + oneTrack);    tracks.add(oneTrack);  })+  (< EOL >)+  "LENGTH (miles):" (< TAB > (oneLength=< FLOAT > | oneLength=< INTEGER >)  {    logger.info("Adding one track length: " + oneLength);    lengths.add(oneLength);  })+  (< EOL >)+  "TRAINS:" (< TAB > | < SPACE >) numTrains=< INTEGER >  (< EOL >)+  (oneTrain=parseTrain()(((< TAB >)*(< EOL >)+)+ | < EOF >)  {    logger.info("Adding one train: " + oneTrain);    trains.add(oneTrain);  })+  < EOF >}private List<List<Token>> parseMOW() : {  List<List<Token>> allTokens = new ArrayList<List<Token >>();  Token nodeStart, nodeEnd, timeStart, timeEnd;}{  "MOW:" (    (< TAB >)+ "between nodes " nodeStart=< INTEGER > " and " nodeEnd=< INTEGER > ", during the time period between " timeStart=< INTEGER > " to " timeEnd=< INTEGER > <SPACE > "minutes" (" from current time")? < DOT > (< TAB >)* (< EOL >)+    {      List<Token> tokens = new ArrayList<Token>();      tokens.add(nodeStart);      tokens.add(nodeEnd);      tokens.add(timeStart);      tokens.add(timeEnd);      allTokens.add(tokens);    }  )+  {    return allTokens;  }}private List<Token> parseArc() : {  List<Token> tokens = new ArrayList<Token>();  Token nodeStart, nodeEnd;}{  "(" nodeStart=< INTEGER > "," nodeEnd=< INTEGER > ")"  {    tokens.add(nodeStart);    tokens.add(nodeEnd);    return tokens;  }}private ParsedTrain parseTrain() : {		Token name;		Token entryTime;		Token originNode;		Token destinationNode;		Token direction;		Token multiplier;		Token length;		Token tob;		Token hazmat;		Token status;		List<List<Token>> arrival;		List<Token> wantTime;}{  "HEADER:" < TAB > name=< TRAIN_NAME > (< TAB >)* (< EOL >)+  "ENTRY TIME (from current time in minutes):" < TAB > entryTime=< INTEGER > (< TAB >)* (< EOL >)+  "ORIGIN NODE:" < TAB > originNode=< INTEGER > (< TAB >)* (< EOL >)+  "DESTINATION NODE:" < TAB > destinationNode=< INTEGER > (< TAB >)* (< EOL >)+  "DIRECTION:" < TAB > direction=< DIRECTION > (< TAB >)* (< EOL >)+  "SPEED MULTIPLIER:" < TAB > (multiplier=< FLOAT > | multiplier = < INTEGER >) (< TAB >)* (< EOL >)+  "TRAIN LENGTH (miles):" < TAB > (length=< FLOAT > | length = < INTEGER >) (< TAB >)* (< EOL >)+  "TOB:" < TAB > tob=< INTEGER > (< TAB >)* (< EOL >)+  "HAZMAT (IH: YES or NO):" < TAB > hazmat=< YESNO > (< TAB >)* (< EOL >)+  "SA STATUS AT ORIGIN:" < TAB > (status=< INTEGER > | status=< NEGATIVE_INTEGER >) (< TAB >)* (< EOL >)+  "SCHEDULED ARRIVAL (NODE: minutes from current time):" arrival=parseArrival() (< EOL >)+  "TERMINAL WANT TIME (WEST or EAST Terminal: minutes from current time):" < TAB > wantTime=parseWantTime()  {    ParsedTrain t = new ParsedTrain(name, entryTime, originNode, destinationNode,      direction, multiplier, length, tob, hazmat, status, arrival, wantTime);    return t;  }}private List<List<Token>> parseArrival() : {  List<List<Token>> arrival;  List<List<Token>> arrivals = new ArrayList<List<Token>>();  Token first, second;}{  < TAB > first=< INTEGER > ":" < TAB > (second=< INTEGER > | second=< NEGATIVE_INTEGER >) (< TAB >)* (    "," arrival=parseArrival()    {      List<Token> newArrival = new ArrayList<Token>();      newArrival.add(first);      newArrival.add(second);      arrivals.add(newArrival);      logger.info("Adding arrival: " + newArrival);      arrivals.addAll(arrival);    }  )?  {    return arrivals;  }}private List<Token> parseWantTime() : {  Token direction;  Token time;}{  direction=< DEPOT > ":" (< SPACE >)? < TAB > time=< INTEGER >  {    List<Token> l = new ArrayList<Token>();    l.add(direction);    l.add(time);    logger.info("Adding want time: " + l);    return l;  }}